## Various question/answer  types


##
## --------------------------------------------------
##
           
#  util

raw"""
    escape_string(str, id)

Escape string does two things:
* replace parameters specified through `{{:a1}}`, `{{:a2}}`, ..., `{{:a6}}` with  the randomized value
* takes the markdown formatting in `str` and converts into "`text/pg`" format

The `id` is generated by the question.

Example
```
julia> str = "*x* = ``{{:a1}}``";

julia> escape_str(str, "ID")
"\$PAR\n\$BITALIC x \$EITALIC = \\(\\verb~\$a1aaID~\\)"
```
"""
function  escape_string(str, id="XXXXXXXXXXXXXXXXXX")
    params = (a1="\\\$a1"*"aa"*id, 
              a2="\\\$a2"*"aa"*id,
              a3="\\\$a3"*"aa"*id,
              a4="\\\$a4"*"aa"*id,
              a5="\\\$a5"*"aa"*id,
              a6="\\\$a6"*"aa"*id,
              )

    str = replace(str, "\\" => "\\\\")
    str = Mustache.render(str, params)
    sprint(io->show(io, "text/pg", Markdown.parse(str)))
    
end


##
## --------------------------------------------------
##



"""
   AbstractQ

A  question has atleast two part: a question (marked up in modified markdown) and an answer, which is typically randomized. In  WeBWorK, there are  tpyically 3 places in  the file where a question needs defintions:  in the preamble  the values are defined (written by `create_answer`);  between `BEGIN_TEXT` and `END_TEXT` the question is asked (written by `show_answer`); and the grading a area  (written by `show_answer).  Not implemented (yet?) are the solutions area or hints.

"""
abstract type AbstractQ end

# create_answer_tpl:  called by create_answer
# question_tpl: called by  show_question
# answer_tpl: called by  show_answer



create_answer(r::AbstractQ) = throw(ArgumentError("no default method"))

function show_question(r::AbstractQ)
    question = escape_string(r.question, r.id)
    Mustache.render(question_tpl(r), (id=r.id, question=question))

end

show_answer(r::AbstractQ) = Mustache.render(answer_tpl(r),  (id=r.id))

show_solution(r::AbstractQ) = ""

## ---------------------------


struct RadioQ <: AbstractQ
    id
    question
    solution
    random
    fixed
    randomize
    ans
end

function radioq(question,
                ans,
                random,
                fixed=""; ## use  [] for none
                solution="",
                randomize=true
                )
    id = string(hash((question,  solution, random,  fixed)))
    RadioQ(id, question, solution, random,  fixed,  randomize, ans)
end


create_answer_tpl(r::RadioQ) = """
\$radio{{:id}} = RadioButtons(
{{{:answers}}}, {{{:answer}}}); 
"""

question_tpl(r::RadioQ) = """

{{{:question}}}

\$PAR

\\{ \$radio{{:id}}->buttons() \\}

"""

answer_tpl(r::RadioQ) = """
ANS( \$radio$(r.id)->cmp() );
"""

function create_answer(r::RadioQ)
    isempty(r.random) && is.empty(r.fixed)  && throw(ArgumentError("need some choice"))

    rands =  join(["\"" *  replace.(string(x), "\"" => "“") *  "\""  for x  in  r.random], ", ")
    if r.randomize
        rands  =   "[" *  rands *  "]"
    end
        
    fixs = "\"" *  replace(string(r.fixed), "\"" => "“")  * "\""
    

    if  isempty(rands)
        answers  = fixs
    elseif isempty(r.fixed)
        answers  =  rands
    else
        answers  =  "[" *  rands * ", " * fixs *  "]"
    end

    answer = r.ans -  1 # 0-based

    Mustache.render(create_answer_tpl(r), (id=r.id, answers=answers, answer=answer))
end



##
## --------------------------------------------------
##

## Numeric answers (random  or  not)
abstract type  AbstractNumericQ <: AbstractQ end

## Some output style mark up

raw"""
   Formula(ex)

For formula  answer, as in 
Example
```
using SymPy
question  = raw"What is  \( ( {{:a1}} x^2 )' \)"
function answer(a)  
  @vars x
  ex = a*x^2
  out = diff(ex,x)
  Formula(out)
end
randomizer = (1:5,)
numericq(question,  answer, randomizer)
```

!!! note 
    This likely has cases not handled well through just call `string(ex)`. If so, the output of the answer should be
    `"Fomula(\\"desired_expression\\")"`, as a string
 
"""
Formula(ex) = "Formula(\"$(string(ex))\")"


raw"""
   List(tuple)

For List comparison, the function  should return a tuple of answers  wrapped in  `List`; e.g. (`List((1,2,3))`).

Example
```
using SymPy
question = raw"What are the elements of  \( {1,2, {{:a1}}  } \)"
function  answer(a)
   List((1,2,a))
end
randomizer = (3:5,)
numericq(question,  answer, randomizer)
```
"""
List(ex::Tuple) = "List(\"" * join(string.(ex), ",") * "\")"
List(v::Vector) = List(tuple(v...))


raw"""
    Interval(a,b)

Intervals have a < b, and are graded regardless of open or closed

Example
```
question = raw"On what  intervals is \( f(x)=(x+1) ⋅ x ⋅ (x-1) \) positive?"
answer() =  List([Interval(-1, 0), Interval(1,Inf)])
numericq(question, answer, ())
```
"""
function Interval(a,b)
    x,y = a < b ? (a,b) : (b,a)
    "Interval($x,$y)"
end




struct NumericQ <: AbstractNumericQ
    id
    vars
    fn
    question
    solution
    tolerance
    ordered
end

## numericq((a1=1:5,a2=[1,2,3]),     # a  tuple of n iterables
##          (a1) -> sin(a1),         # an n-ary function giving answer for a combination of values
##          "What  is sin({{:a1}})?",# a string. Use {{:ai}}  to  reference random parameters
##          "It is `sin({{:a1}})`.") # a string.

"""
    numericq(question, ans_fn, [random];  solution,  tolerance=1e-4,  ordered=false)

* question is  typically generated using `raw` and may includ basic markdown and  LaTex wehre `\\( \\)`  and  `\\[  \\]` are
used for   inline math and display math.


 References to randomized variables is  through  `{{:a1}}`, `{{:a2}}`, `{{:a3}}`.

* The answer function is  an n-ary function of the  randomized parameters

* the  random parameters are specified  by  0,1,2,or 3  iterable objects (e.g. `1:5` or `[1,2,3,5]`) combined in a tuple (grouped
with parentheses; use  `(itr,)` if only 1 randomized parameter.

* tolerance is  an absolute tolerance.

* `ordered` is only for the case where the output is a list and you want an exact order

Examples

```
using SymPy, SpecialFunctions
numericq("What is the value  of  `airy(pi)`?", () -> airyai(pi), ())
numericq("What is ``{{:a1}} + {{:a2}}``?",  (a,b) -> a+b, (1:5, 1:5))
numericq("What is ``{{:a1}}*{{:a2}}*{{:a3}}``?",  (a,b) -> a+b, (1:5, 1:5,1:5))  ## parses fine, as `` in Markdown is LaTeX
numericq("What is \\({{:a1}}⋅{{:a2}}⋅{{:a3}}\\)?",  (a,b) -> a+b, (1:5, 1:5,1:5)) ## note \\cdot, not *, unfortunate parsing o/w
numericq("Estimate from your graph the \\(x\\)-intercept.", ()-> 2.3, ();  tolerance=0.5)
numericq("What is \\( \\infty  \\)?",  () ->  Inf, ())
numericq("What is \\( {1,2,{{:a1}} } \\)?",  (a) -> List((1,2,a)), (3:6), ordered=true)
numericq("What is the derivative of  \\( \\sin(x) \\)?", () -> (@vars x;  Formula(diff(sin(x),x))),  ())
```


!! note "TODO"
   Should consolidate arguments  to  `cmp` (`tolerance`,   `ordered`)
   For `Interval` types,  may  need  to  set the context.

"""
function numericq(
    question,
    fn,
    vars=(); # tuple  
    solution="",
    tolerance=1e-4,
    ordered=false # for the List type
)
    length(vars) == 0 && return fixed_numericq(fn, question, solution, tolerance, ordered)
    id = string(hash((vars, fn, question, solution)))
    NumericQ(id, vars, fn, question, solution, tolerance,ordered)
end


question_tpl(r::AbstractNumericQ) =  """

{{{:question}}}

\$PAR

\\{ ans_rule(60) \\}

"""

create_answer_tpl(r::AbstractNumericQ) = """
\$list{{:id}} = [
    {{{:answers}}}
];
\$index{{:id}} = random(0,{{:M}}-1, 1);
{{#:inds}}
\$a{{.}}aa{{:id}} = \$list{{:id}}->[\$index{{:id}}][{{.}}-1];
{{/:inds}}
{{#:ainds}}
\$ans{{.}}aa{{:id}}=Compute("\$list{{:id}}->[\$index{{:id}}][{{:N}}+{{.}}-1]");
{{#:ainds}}

"""

# map iterables,f into a "list" for precomputed  randomized answers
function make_values(vals, f)
    buf = IOBuffer()
    M = 0
    first = true
    for xs  in Base.Iterators.product(vals...)
        if first
            first=false
        else
            println(buf, ",")
        end
        print(buf, "[" *  join(string.(xs),", "))
        for fᵢ in f
            print(buf,  ", ")
            print(buf, string(fᵢ(xs...)))
        end
        print(buf,  "]")
        M += 1
    end
    String(take!(buf)), M
end


function create_answer(r::AbstractNumericQ)
    N = length(r.vars) 
    answers, M = make_values( r.vars, (r.fn,))    
    Mustache.render(create_answer_tpl(r), (id=r.id, answers=answers, inds=1:N, ainds=1:1, N=N, M=M))
end


##
## --------------------------------------------------
##


struct FixedNumericQ  <: AbstractNumericQ
    id 
    question
    solution
    answer
    tolerance
    ordered
end

function  fixed_numericq(fn, question,  solution="",tolerance=1e-4, ordered=false)

    id = string(hash((question, solution)))
    FixedNumericQ(id, question, solution, fn(),  tolerance,ordered)
end


function answer_tpl(r::Union{NumericQ, FixedNumericQ})
    strict = r.ordered ? ", ordered=>'strict'" :  ""
    """
ANS( \$ans1aa{{:id}}->cmp(tolerance=>$(r.tolerance))  $strict );
"""
end




create_answer(r::FixedNumericQ) = """
    \$ans1aa$(r.id) =  Compute($(r.answer));
"""

##
##--------------------------------------------------
##



##
## --------------------------------------------------
##
##  Allow for  shaared randomness
struct MultiNumericQ <: AbstractNumericQ
    id
    vars
    fns
    questions
    solutions
    tolerances
end

"""
    multinumericq(questions, answer_fns, vars, solutions; tolerances=1e-4*zeros(length(questions)))

Used to share randomized parameters over several questions.

Example:

```
q1 = raw" What is ``{{:a1}} + {{:a2}}`` ?"
q2 = raw" What is ``{{:a1}} - {{:a2}}`` ?"

a1 = (x,y) -> x+y 
a2 = (x,y) -> x-y

randomizer = (2:6, 2:6)

multinumericq((q1,q2), (a1,a2), randomizer)
```
"""
function multinumericq(questions, fns, vars, solutions=""; tolerances=1e-4*ones(length(questions)))

    id =  string(hash((questions, fns, vars)))
    MultiNumericQ(id, vars, fns, questions, solutions, tolerances)
    
end

function create_answer(r::MultiNumericQ)
    N = length(r.vars) 
    #answers, M = make_values(Val(N), r.vars, r.fn)
    answers, M = make_values( r.vars, r.fns)    
    Mustache.render(create_answer_tpl(r), (id=r.id, answers=answers, inds=1:N,ainds=1:length(r.fns), N=N, M=M))
end

function answer_tpl(r::MultiNumericQ)
    buf = IOBuffer()
    for i in eachindex(r.fns)
        println(buf, "ANS( \$ans$(i)aa{{:id}}->cmp(tolerance=>$(r.tolerances[i]) ));")
    end
    String(take!(buf))
end
function show_question(r::MultiNumericQ)
    buf = IOBuffer()
    for question in r.questions
        question = escape_string(question, r.id)
        println(buf, Mustache.render(question_tpl(r), (id=r.id, question=question)))
    end
    String(take!(buf))
end

