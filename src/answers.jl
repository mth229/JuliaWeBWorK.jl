## Various question/answer  types


##
## --------------------------------------------------
##
           
#  util

raw"""
    escape_string(str, id)

Escape string does two things:
* replace parameters specified through `{{:a1}}`, `{{:a2}}`, ..., `{{:a6}}` with  the randomized value
* takes the markdown formatting in `str` and converts into "`text/pg`" format

The `id` is generated by the question.

Example
```
julia> str = "*x* = ``{{:a1}}``";

julia> escape_str(str, "ID")
"\$PAR\n\$BITALIC x \$EITALIC = \\(\\verb~\$a1aaID~\\)"
```
"""
function  escape_string(str, id="XXXXXXXXXXXXXXXXXX")
    params  =  Dict()
    for i in 1:6
        k = Symbol("a"*string(i))
        v = "\\\$a"*string(i)*"aa"*id
        params[k] = v
    end
    
    Xparams = (a1="\\\$a1"*"aa"*id, 
              a2="\\\$a2"*"aa"*id,
              a3="\\\$a3"*"aa"*id,
              a4="\\\$a4"*"aa"*id,
              a5="\\\$a5"*"aa"*id,
              a6="\\\$a6"*"aa"*id,
              )

    str = replace(str, "\\" => "\\\\")
    str = Mustache.render(str, params)
    sprint(io->show(io, "text/pg", Markdown.parse(str)))
    
end


##
## --------------------------------------------------
##




"""
   AbstractQ

A  question has atleast two part: a question (marked up in modified markdown) and an answer, which is typically randomized. In  WeBWorK, there are  tpyically 3 places in  the file where a question needs defintions:  in the preamble  the values are defined (written by `create_answer`);  between `BEGIN_TEXT` and `END_TEXT` the question is asked (written by `show_answer`); and the grading a area  (written by `show_answer).  Not implemented (yet?) are the solutions area or hints.

"""
abstract type AbstractQ end

# create_answer_tpl:  called by create_answer
# question_tpl: called by  show_question
# answer_tpl: called by  show_answer



create_answer(r::AbstractQ) = throw(ArgumentError("no default method"))

function show_question(r::AbstractQ)
    question = escape_string(r.question, r.id)
    answer = "\\\$answer$(r.id)"
    Mustache.render(question_tpl(r), (id=r.id, question=question, answer=answer))

end

function show_answer(r::AbstractQ)
    answer = "\$answer$(r.id)"
    Mustache.render(answer_tpl(r),  (id=r.id, answer=answer))
end

show_solution(r::AbstractQ) = ""


## --------------------------------------------------
struct Randomizer
    id
    vars
    N
end
#  length  is number of iterators; use length(r.vars)  for  length  of  iterables  (M)
Base.length(r::Randomizer) = r.N

"""
    randomizer(vars...)

A  means to share the randomization across questions

Example

```
r = randomizer(1:3)
q1 =  numericq("What is  ``2-{{:a1}}?``", (a) -> 2-a,  r)
q2 =  numericq("What is  ``3-{{:a1}}?``", (a) -> 3-a,  r)
Page("test", (r, q1, q2))
"""
function randomizer(args...; id=nothing)
    _id = id == nothing ? string(hash(args)) : id
    N = length(args)

    Randomizer(_id, args, N)
end

randomizer(r::Randomizer) = r

function create_answer(r::Randomizer)
    id, M = r.id, length(r.vars)
    """
\$randomizer$(id) = random(0,$M-1, 1);
"""
end
show_question(r::Randomizer) =  ""
show_answer(r::Randomizer) =  ""

Base.iterate(r::Randomizer) = Base.iterate(Base.Iterators.product(r.vars...))
Base.iterate(r::Randomizer, s) = Base.iterate(Base.Iterators.product(r.vars...),s)


## ---------------------------


struct RadioQ <: AbstractQ
    id
    question
    solution
    random
    fixed
    randomize
    ans
end

function radioq(question,
                ans,
                random,
                fixed=""; ## use  [] for none
                solution="",
                randomize=true
                )
    id = string(hash((question,  solution, random,  fixed)))
    RadioQ(id, question, solution, random,  fixed,  randomize, ans)
end


create_answer_tpl(r::RadioQ) = """
\$answer{{:id}} = RadioButtons(
{{{:answers}}}, {{{:answer}}}); 
"""

question_tpl(r::RadioQ,i=1) = """

{{{:question}}}

\$PAR

\\{ \$answer{{:id}}->buttons() \\}

"""

answer_tpl(r::RadioQ) = """
ANS( \$answer$(r.id)->cmp() );
"""

function create_answer(r::RadioQ)
    isempty(r.random) && is.empty(r.fixed)  && throw(ArgumentError("need some choice"))

    rands =  join(["\"" *  replace.(string(x), "\"" => "“") *  "\""  for x  in  r.random], ", ")
    if r.randomize
        rands  =   "[" *  rands *  "]"
    end
        
    fixs = "\"" *  replace(string(r.fixed), "\"" => "“")  * "\""
    

    if  isempty(rands)
        answers  = fixs
    elseif isempty(r.fixed)
        answers  =  rands
    else
        answers  =  "[" *  rands * ", " * fixs *  "]"
    end

    answer = r.ans -  1 # 0-based

    Mustache.render(create_answer_tpl(r), (id=r.id, answers=answers, answer=answer))
end


##
##  --------------------------------------------------
##

MultiChoiceQ <: AbstractQ
id
question
answer
vals
random
fixed
end

##  Choices is  ((random1,random2,  ...),  fixed) or just (random,random, ...random)
function multiplechoiceq(question, choices, answer_fn, vals)

    id  =  string(hash(question, choices,  answer_fn, vals))
    if  isa(choices[1],  AbstractVector) ||  isa(choices[1],  Tuple)
        random  = choices[1]
        fixed=   choices[2]
    else
        random  = choices
        fixed  = nothing
    end
    
    MultiChoiceQ(id, question, answer vals, random, fixed)
end


##  XXX
function create_answer(r::MultiChoiceQ)

    ## Need to  randomize  here
    
#     $mc = new_checkbox_multiple_choice();
# $mc -> qa (
# "Select all expressions that are equivalent to  
# \( e^{x^2 + 1/x} \).  There may be more than
# one correct answer.", 
# "\( e^{x^2} e^{1/x} \)$BR",
# "\( e^{x^2} e^{x^{-1}} \)$BR",                
# "\( e^{ (x^3+1) / x } \)$BR",
# );
# $mc -> extra(
# "\( \displaystyle \frac{ e^{x^2} }{ e^x } \)$BR",
# "\( e^{x^2} + e^{1/x} \)$BR",
# );
# $mc -> makeLast("None of the above");
end

show_question(r::MultiChoiceQ) = """
\{ $mc$(r.id) -> print_q() \}
$BR
\{ $mc$(r.id) -> print_a() \}
"""
end

show_answer(r::MultiChoiceQ) =  """    
 ANS( checkbox_cmp( $mc$(r.id)->correct_ans() ) );
"""



##
## --------------------------------------------------
##

## Numeric answers (random  or  not)
## XXX This is more general (text box entries?)
abstract type  AbstractNumericQ <: AbstractQ end

## Some output style mark up

raw"""
   Formula(ex)

For formula  answer, as in 
Example
```
using SymPy
question  = raw"What is  \( ( {{:a1}} x^2 )' \)"
function answer(a)  
  @vars x
  ex = a*x^2
  out = diff(ex,x)
  Formula(out)
end
randomizer = (1:5,)
numericq(question,  answer, randomizer)
```

!!! note 
    This likely has cases not handled well through just call `string(ex)`. If so, the output of the answer should be
    `"Fomula(\\"desired_expression\\")"`, as a string
 
"""
Formula(ex) = "Formula(\"$(string(ex))\")"


raw"""
   List(tuple)

For List comparison, the function  should return answers  wrapped in  `List`; e.g. (`List(1,2,3)`).

Example
```
using SymPy
question = raw"What are the elements of  \( {1,2, {{:a1}}  } \)"
function  answer(a)
   List((1,2,a))
end
randomizer = (3:5,)
numericq(question,  answer, randomizer)
```
"""
List(ex::Tuple) = "List(" * join(string.(ex), ",") * ")"
List(v::Vector) = List(tuple(v...))


raw"""
    Interval(a,b)

Intervals have a < b, and are graded regardless of open or closed

Example
```
question = raw"On what  intervals is \( f(x)=(x+1) ⋅ x ⋅ (x-1) \) positive?"
answer() =  List([Interval(-1, 0), Interval(1,Inf)])
numericq(question, answer, ())
```
"""
function Interval(a,b)
    x,y = a < b ? (a,b) : (b,a)
    "Interval($x,$y)"
end


"""
    Plot(p)

Convert plot  to `png`  object; run `Base64.base64encode`; wrap  for inclusion into `img` tag.

Works for `Plots`, and would work for other graphing problems with a   `show(io, MIME("text/png"), p)` method.
"""
function Plot(p)
    io  = IOBuffer()
    show(io, MIME("image/png"), p)
    data = Base64.base64encode(take!(io))
    close(io)

    io = IOBuffer()
    print(io,"data:image/gif;base64,")
    print(io,data)
    String(take!(io))
end


##
## --------------------------------------------------
##

struct NumericQ <: AbstractNumericQ
    id
    vars
    fn
    question
    solution
    tolerance
    ordered
end

"""
    MathObject(r)

What type of [MathObject](https://webwork.maa.org/wiki/Introduction_to_MathObjects) to create?  Defaults to "List", but "" (`PlotQ`) or "String"  (`StringQ`)  are useful.
"""
MathObject(r::AbstractNumericQ) = "List"


"""
    TypePartial

Ability to modify just  part of the `create_answer_tpl` for "AbstractNumericQ" for a  given type. (e.g., `StringQ`)
"""
TypePartial(r::AbstractNumericQ) = ""

## numericq((a1=1:5,a2=[1,2,3]),     # a  tuple of n iterables
##          (a1) -> sin(a1),         # an n-ary function giving answer for a combination of values
##          "What  is sin({{:a1}})?",# a string. Use {{:ai}}  to  reference random parameters
##          "It is `sin({{:a1}})`.") # a string.

"""
    numericq(question, ans_fn, [random];  solution,  tolerance=1e-4,  ordered=false)

* question is  typically generated using `raw` and may includ basic markdown and  LaTex wehre `\\( \\)`  and  `\\[  \\]` are
used for   inline math and display math.


 References to randomized variables is  through  `{{:a1}}`, `{{:a2}}`, `{{:a3}}`.

* The answer function is  an n-ary function of the  randomized parameters

* the  random parameters are specified  by  0,1,2,or 3  iterable objects (e.g. `1:5` or `[1,2,3,5]`) combined in a tuple (grouped
with parentheses; use  `(itr,)` if only 1 randomized parameter.

* tolerance is  an absolute tolerance.

* `ordered` is only for the case where the output is a list and you want an exact order

Examples

```
using SymPy, SpecialFunctions
numericq("What is the value  of  `airy(pi)`?", () -> airyai(pi), ())
numericq("What is ``{{:a1}} + {{:a2}}``?",  (a,b) -> a+b, (1:5, 1:5))
numericq("What is ``{{:a1}}*{{:a2}}*{{:a3}}``?",  (a,b) -> a+b, (1:5, 1:5,1:5))  ## parses fine, as `` in Markdown is LaTeX
numericq("What is \\({{:a1}}⋅{{:a2}}⋅{{:a3}}\\)?",  (a,b) -> a+b, (1:5, 1:5,1:5)) ## note \\cdot, not *, unfortunate parsing o/w
numericq("Estimate from your graph the \\(x\\)-intercept.", ()-> 2.3, ();  tolerance=0.5)
numericq("What is \\( \\infty  \\)?",  () ->  Inf, ())
numericq("What is \\( {1,2,{{:a1}} } \\)?",  (a) -> List((1,2,a)), (3:6), ordered=true)
numericq("What is the derivative of  \\( \\sin(x) \\)?", () -> (@vars x;  Formula(diff(sin(x),x))),  ())
```

Output of `Plots` can be  used in a  question by wrapping figure in  `Plot(p)`.  (This will  not show up  in  a  hard copy.)

```
using Plots
p = plot(sin, 0, 2pi);
plot!(zero);
q = numericq("![A Plot](\$(Plot(p))) This is a plot  of ``sin`` over what interval?", ()->Interval(0, 2pi),())
```

!! note "TODO"
   Should consolidate arguments  to  `cmp` (`tolerance`,   `ordered`)
   For `Interval` types,  may  need  to  set the context.

"""
function numericq(
    question,
    fn,
    vars=(); # tuple ##  Randomizer
    solution="",
    tolerance=1e-4,
    ordered=false # for the List type
)
    length(vars) == 0 && return fixed_numericq(fn, question, solution, tolerance, ordered)
    id = string(hash((vars, fn, question, solution)))
    NumericQ(id, vars, fn, question, solution, tolerance,ordered)
end


question_tpl(r::AbstractNumericQ) =  """

{{{:question}}}

\$PAR

\\{ ans_rule(60) \\}

"""
create_answer_tpl(r::AbstractNumericQ) = """
@list{{:id}} = (
    {{{:answers}}}
);

{{>:TypePartial}}

{{{:randomizer}}}
{{#:inds}}
\$a{{.}}aa{{:id}} = \$list{{:id}}[\$randomizer{{:id}}][{{.}}-1];
{{/:inds}}
\$answer{{:id}}= {{:MathObject}}(\$list{{:id}}[\$randomizer{{:id}}][{{:N}}]);

"""

## The key to using Julia with randomized questions is to *precompute* the
## answers for all the possible values. If the event space is modest, this is not
## an onerous task. Here, we return a vector of arrays, with  strings escaped.
# map iterables,f into a "list" for precomputed  randomized answers
function make_values(vals, f; escape=false)
    buf = IOBuffer()
    M = 0
    first = true
    _vals =  isa(vals, Randomizer) ? vals : Base.Iterators.product(vals...)
    for xs  in _vals #
        if first
            first=false
        else
            println(buf, ",")
        end
        print(buf, "[" *  join(string.(xs),", "))
        print(buf,  ", ")
        val = f(xs...)
        if isa(val, String)
            val = "\"" * val *  "\""
        end
        print(buf, val)
        print(buf,  "]")
        M += 1
    end
    String(take!(buf)), M
end


function create_answer(r::AbstractNumericQ)
    N = length(r.vars)
    all_answers, M = make_values( r.vars, r.fn)

    # which randomizer do we use, a new one or recycled one?
    if (r.vars isa Randomizer)
        randomizer= "\$randomizer$(r.id) = \$randomizer$(r.id);"
    else
        randomizer =  "\$randomizer$(r.id) = random(0,$M-1, 1);"
    end

    
    Mustache.render(create_answer_tpl(r), (id=r.id, answers=all_answers, randomizer=randomizer,
                                           MathObject=MathObject(r), TypePartial=TypePartial(r),
                                           inds=1:N, ainds=1:1, N=N, M=M))
end


##
## --------------------------------------------------
##


struct FixedNumericQ  <: AbstractNumericQ
    id 
    question
    solution
    answer
    tolerance
    ordered
end

function  fixed_numericq(fn, question,  solution="",tolerance=(1e-4), ordered=false)

    id = string(hash((question, solution)))
    FixedNumericQ(id, question, solution, fn(),  tolerance,ordered)
end


function answer_tpl(r::Union{NumericQ, FixedNumericQ})
    strict = r.ordered ? ", ordered=>'strict'" :  ""
    """
ANS( {{{:answer}}}->cmp(tolerance=>$(r.tolerance), tolType=>"absolute"  $strict ));
"""
end




create_answer(r::FixedNumericQ) = """
    \$answer$(r.id) =  List($(r.answer));
"""

##
## --------------------------------------------------
##

struct StringQ <: AbstractNumericQ
    id
    vars
    fn
    question
    solution
end
MathObject(r::StringQ) = "String"

"""
    stringq(question, answer, values)

Answer among limited set of strings. The strings available are all the possible outputs of `answer` (a function) over all possible values.

Examples:

```
q1 = stringq(raw"Is \\({{:a1}} > 0\\)? (yes/no)", (a) -> ("no","yes")[(a>0) + 1], (-3:3,))
q2 = stringq("Spell  out {{:a1}}", (a) -> ("one","two","three")[a], (1:3,))    
```
"""
function stringq(question, fn, vars, solution="")
    length(vars) == 0 && throw(ArgumentError("why?"))
    id = string(hash((vars, fn, question, solution)))
    StringQ(id, vars, fn, question, solution)
end

## Partial for create_answer_tpl
TypePartial(r::StringQ) = """
\$N =  scalar @list{{:id}};
foreach (0 .. (\$N-1)) {
  Context()->strings->add(qq(\$list{{:id}}[\$_][1])=>{});
};
"""
    
## Must add Context()->strings->add(A => {}) for  each; o/w this is
## same as numeric
# create_answer_tpl(r::StringQ) = """
# @list{{:id}} = (
#     {{{:answers}}}
# );

# \$N =  scalar @list{{:id}};
# foreach (0 .. (\$N-1)) {
#   Context()->strings->add(qq(\$list{{:id}}[\$_][1])=>{});
# };

# {{{:randomizer}}}
# {{#:inds}}
# \$a{{.}}aa{{:id}} = \$list{{:id}}[\$randomizer{{:id}}][0];
# {{/:inds}}
# \$answer{{:id}}={{:MathObject}}(\$list{{:id}}[\$randomizer{{:id}}][1]);

# """

function answer_tpl(r::StringQ)
    """
ANS( {{{:answer}}}->cmp());
"""
end
    

##
##--------------------------------------------------
##

struct PlotQ <: AbstractNumericQ
    id
    vars
    fn
    question
end
MathObject(r::PlotQ) = ""

##  randomized plot
## fn should return Plot() call
function plotq(caption, fn, vars)
    length(vars) == 0 && throw(ArgumentError("Use ![]() syntax"))
    id = string(hash((caption,   fn, vars)))
    PlotQ(id, vars, fn, caption)
end

# # No enclosing List() here
# create_answer_tpl(r::PlotQ) = """
# @list{{:id}} = (
#     {{{:answers}}}
# );
# {{:randomizer}}
# {{#:inds}}
# \$a{{.}}aa{{:id}} = \$list{{:id}}[\$randomizer{{:id}}][0];
# {{/:inds}}
# \$answer{{:id}}=\$list{{:id}}[\$randomizer{{:id}}][1];

#  """


#question_tpl(r::PlotQ) = """
#<figure><img src="{{{:answer}}}"  alt="image"><figcaption>{{{:question}}}</figcaption></figure>
#"""

function show_question(r::PlotQ)
    caption  = escape_string(r.question, r.id)
    """
END_TEXT
\$image$(r.id) = MODES(
HTML=>qq(<figure><img src=\${answer$(r.id)}><figcaption>$(caption)</figcaption></figure>),
TeX=>qq([$(r.question)](image))
);
BEGIN_TEXT
\$image$(r.id)
"""
end

#     buf = IOBuffer()
#     println(buf,"""
# END_TEXT
# \$id = MODES(
# """)
#     print(buf, """HTML=>qq(<figure><img src="\${ans1aa""")
#     print(buf, r.id)
#     print(buf, """}"></figure>),""")
#     println(buf, "")
#     println(buf,"""
# TeX=>'insert tex here'
# );
# BEGIN_TEXT
# \$id
# """)
            
#     out = String(take!(buf))
#     out
# end
    
#question_tpl(r::PlotQ) = """
#<figure><img src="{{{:answer}}}"  alt="image"><figcaption>{{{:question}}}</figcaption></figure>
#"""

show_answer(r::PlotQ) = ""

# ##
# ## --------------------------------------------------
# ##
# ##  Allow for  shared randomness
# struct MultiNumericQ <: AbstractNumericQ
#     id
#     vars
#     fns
#     questions
#     solutions
#     tolerances
# end

# """
#     multinumericq(questions, answer_fns, vars, solutions; tolerances=(1e-2)*zeros(length(questions)))


# DON'T USE: use  randomizer instead....


# Used to share randomized parameters over several questions.

# Example:

# ```
# q1 = raw" What is ``{{:a1}} + {{:a2}}`` ?"
# q2 = raw" What is ``{{:a1}} - {{:a2}}`` ?"

# a1 = (x,y) -> x+y 
# a2 = (x,y) -> x-y

# randomizer = (2:6, 2:6)

# multinumericq((q1,q2), (a1,a2), randomizer)


# !!! note
#     THIS NEEDS TO BE GENERALIZED. As it it only shares randomness  over numeric questions. We need instead a means  to share  
#     The random M.

# ```
# """
# function multinumericq(questions, fns, vars, solutions=""; tolerances=(1e-2)*ones(length(questions)))

#     id =  string(hash((questions, fns, vars)))
#     MultiNumericQ(id, vars, fns, questions, solutions, tolerances)
    
# end

# create_answer_tpl(r::MultiNumericQ) = """
# @list{{:id}} = (
#     {{{:answers}}}
# );
# {{:randomizer}}
# {{#:inds}}
# \$a{{.}}aa{{:id}} = \$list{{:id}}[\$randomizer{{:id}}][{{.}}-1];
# {{/:inds}}
# {{#:ainds}}
# \$answer{{.}}{{:id}}=List(\$list{{:id}}[\$randomizer{{:id}}][{{:N}}+{{.}}-1]);
# {{#:ainds}}

#  """

# function create_answer(r::MultiNumericQ)
#     N = length(r.vars) 
#     #answers, M = make_values(Val(N), r.vars, r.fn)
#     answers, M = make_values( r.vars, r.fns)    
#     Mustache.render(create_answer_tpl(r), (id=r.id, answers=answers, inds=1:N,ainds=1:length(r.fns), N=N, M=M))
# end

# function answer_tpl(r::MultiNumericQ)
#     buf = IOBuffer()

#     for (i,question) in enumerate(r.questions)
#         println(buf, """ANS( \$answer$(i){{:id}}->cmp(tolerance=>$(r.tolerances[i]), tolType=>"absolute" ));""")
#     end
#     String(take!(buf))
# end
# function show_question(r::MultiNumericQ, args...)
#     buf = IOBuffer()
#     for (i,question) in enumerate(r.questions)
#         question = escape_string(question, r.id)
#         println(buf, Mustache.render(question_tpl(r), (id=r.id, question=question)))
#     end
#     String(take!(buf))
# end




##
## ------------- Output only widgets ------------------------------
##

abstract type AbstractOutputQ <: AbstractQ end

show_answer(r::AbstractOutputQ) = ""

struct IFrameQ <: AbstractOutputQ
    id
    url
    width
    height
    alt
end

"""
    iframe(url, [alt]; [width], [height])

Embed the web page specified in `url` in the page.

Example (from https://webwork.maa.org/wiki/IframeEmbedding1)

```
r = iframe("https://docs.google.com/presentation/d/1pk0FxsamBuZsVh1WGGmHGEb5AlfC68KUlz7zRRIYAUg/embed#slide=id.i0";
    width=555, height=451)
```
"""
function iframe(url, alt="An embedded web page"; width=600, height=400)
    id = hash((url, alt, width,height))
    IFrameQ(id, url, width, height, alt)
end

create_answer_tpl(r::IFrameQ) = """
\$iframe{{:id}} = MODES(
HTML=> 
"<iframe src='$(r.url)'
frameborder='0' width='{{:width}}' height='{{:height}}'></iframe>", 
TeX =>
"{{:alt}}"
);
"""

function create_answer(r::IFrameQ)
    Mustache.render(create_answer_tpl(r), (id=r.id, width=r.width, height=r.height, alt=r.alt))
end

function show_question(r::IFrameQ, args...)
   """
\${BCENTER}
\$iframe$(r.id)
\${ECENTER}
"""
end

show_answer(r::IFrameQ) = ""


##
## --------------------------------------------------
##


struct KnowlLink <: AbstractOutputQ
    txt
    alt
end

"""
    hint(text, tag="hint...")

Little inline popup.
[docs](https://webwork.maa.org/wiki/Knowls)
"""
hint(text, tag="hint...")  =  KnowlLink(text, tag)

create_answer(r::KnowlLink) = ""

function show_question(r::KnowlLink, args...)
    txt = replace(r.txt, "\\"=>"\\\\")
    txt = sprint(io -> show(io, "text/pg",  Markdown.parse(txt)))
    txt = replace(txt, "\\"=>"\\\\")
    """
\\{
knowlLink("$(r.alt)",
value=>escapeSolutionHTML(EV3P("$(txt)")), base64=>1);
\\}
"""
end
                 

##
## --------------------------------------------------
##


